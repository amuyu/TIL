# Merge
원격 저장소의 변경 사항을 로컬 저장소에 반영할 때 git fetch 명령어 실행 후,
git merge 명령어로 병합을 진행한다.

git pull 명령어는 git retch 명령어와 git merge 명령어를 순서대로 실행하는 명령어다.
가능하면 git retch 명령어로 원격 브랜치의 이력 상태를 파악한 후, git merge 명령어로
병합하는 것이 좋다.

# squash 병합
git merge 명령어에 --squash 옵션을 사용하면 변경 사항을 파일에 반영해 Staging Area에
등록된 상태로 둔다. 즉 BLOB 파일은 만들지만 커밋 객체는 만들지 않는다.
명시적으로 커밋을 실행해 병합을 완료하면 변경 내역을 반영하지만 별개의 커밋을 생성해
브랜치의 이력을 복잡하지 않게 관리하거나 다사ㅜ의 커밋으로 나누어진 변경 내역을 하나로
합칠 때 유용하다.

# fast-forward 병합
이것은 엄밀하게 말하면 병합이라고 하기보다 정렬에 가깝다.
병합 커밋을 만든 것이 아니라 기존 브랜치가 가리키는 커밋을 다른 브랜치가 가리키는 커밋으로
옮겼을 뿐이다.

Git 은 병합 시에 병합 대상 브랜치에 추가된 커밋이 현재 브랜치의 끝에서 시작한 경우
간단하게 현재 브랜치의 위치를 옮기는 fast-forward 병합으로 병합을 대신한다.

# recursive 병합
fast-forward 병합이 불가능한 경우 git 은 recursive 전략을 사용한다.
recursive 전략은 3-way merge 알고리즘을 기반으로 2개 브랜치의 마지막 커밋을 병합한다.
병합 결과 생성된 새로운 커밋의 내용을 보면 부모 커밋이 두개다.
```sh
git cat-file -p dabd63e
```
변경 사항 사이에 충돌이 발생한 경우 사용자가 충돌이 발생한 파일을 수정한 후 계속 병합을 진행한다.

# rebase
이력을 정리하는 또 다른 방법으로 rebase 가 있다.
현재 브랜치의 커밋을 다른 브랜치의 마지막 커밋에 맞추어 재작성한다.
변경 사항을 새로운 시작점에 맞추어 재정렬한다.

# cherry-pick
브랜치 전체가 아니라 특정 커밋만 골라 병합하려면 cherry-pick 병합을 사용한다.


# ref
[Gerrit을 이용한 코드 리뷰 시스템 - Gerrit과 Git](https://d2.naver.com/helloworld/1859580)