# 2장 자바와 비교해 보는 코틀린
자바의 자료형은 값 자체를 직접 저장하는 primitive type 과 객체의 참조값을 저장하는 reference type 으로 나뉩니다.
코틀린은 모든 타입을 객체로 표현하고 원시 타입과 래퍼 클래스를 구분하지 않습니다.

## 2.1 기본 자료형
### 숫자
숫자를 표현하는 모든 자료형은 `Number` 클래스를 상속합니다.
Byte, Double, Float, Int, Long, Short

자바의 Number 클래스와 마찬가지로 코틀린에서도 값을 다른 자료형으로 바꿔주는 함수를 제공합니다.
toBytes(), toChar(), toDouble(), toFloat(), toInt(), toLong(), toShort()

사칙연산은 자바와 동일하나 비트 연산자의 이름은 자바와 다릅니다.
|Java|Kotlin|
|---|---|
|&|and|
|||or|
|^|xor|
|~|inv|
|<<|shl|
|>>|shr|
|>>>|ushr|

### 문자
자바에서는 문자에 해당하는 아스키 코드를 문자 자료형에 숫자 형태로 대입할 수 있지만,
코틀린에서는 문자 자료형에는 문자만 대입할 수 있습니다.
다른 자료형의 값을 문자 자료형에 대입하는 것이 불가피할 경우, `toChar()` 를 사용할 수 있습니다.

### 논리
자바와 동일한 형태로 사용합니다.

### 문자열
자바에서는 문자열 내 특정 위치에 접근하기 위해 `charAt()` 메서드를 사용하지만
코틀린에서는 `get()` 메서드 혹은 대괄호와 인덱스를 사용합니다.

formatted string 을 사용하려면 자바와 동일하게 `String.format()` 함수를 사용할 수 있습니다.
string template 기능을 사용하면 `String.format()` 함수와 달리 템플릿 문자열 내에 직접 인자를 대입합니다.
템플릿 문자열에 포함할 인자는 $ 를 붙여 구분하고 인자로 표현식을 넣고 싶다면 표현식 부분을 중괄호로 구분하면 됩니다.

### 배열
배열 타입이 별도로 존재하는 자바와 달리 코틀린에서는 `Array` 클래스로 표현합니다.
자바의 원시 타입 배열고 상응하는 코틀린 클래스는 다음과 같습니다.
|Java|Kotlin|
|---|---|
|byte[]|ByteArray|
|double[]|DoubleArray|
|float[]|FloatArray|
|int[]|IntArray|
|long[]|LongArray|
|short[]|ShortArray|

자바로 작성된 코드에서 배열을 인자로 받거나 가변인자를 사용하는 경우, 스프레드 연산자(*) 를 사용해야
코틀린의 배열을 인자로 전달할 수 있습니다.

코틀린을 작성된 함수는 가변인자에 배열을 전달하는 경우에만 스프레드 연산자를 사용합니다.


## 2.2 컬렉션
코틀린에서 Collection 은 자바에서 제공하는 클래스들을 그대로 사용합니다.

코틀린에서는 컬렌션 내 자료의 수정 가능 여부에 따라 컬렉션의 종류를 구분합니다.
kotlin.collections.List <= kotlin.collections.MutableList

자바의 컬렉션에서는 자료에 포함된 특정 항목에 접근할 때 get/set 같은 메서드를 사용합니다.
코틀린에서는 배열의 특정 원소에 접근하는 방법과 동일하게 컬렉션 내 항목에 접근합니다.

맵을 생성하는 함수들은 키와 값을 인자로 받기 위해 `Pair` 클래스를 사용합니다.
이 때, `to` 함수를 사용하면 `Pair` 형태의 값을 좀 더 편리하게 생성할 수 있습니다.


## 2.3 클래스 및 인터페이스
### 클래스와 인터페이스 선언 및 생성
클래스와 인터페이스 선언은 자바와 거의 동일합니다.
코틀린에서는 본체 없이 클래스와 인터페이스를 선언할 수 있습니다.

코틀린에서는 인스턴스를 생성하기 위해 new 키워드를 사용하지 않습니다.

추상 클래스와 인터페이스 선언은 자바와 동일하지만 인스턴스를 생성하는 형태는 다릅니다.
```kotlin
abstract class Foo {
    abstract fun bar()
}

var foo = object: Foo() {
    override fun bar() {
        //implementation
    }
}
```

### 프로퍼티
자바에서는 클래스 내에 자료를 저장하고 접근하기 위해 field 와 method 를 사용합니다.
특정 field 에 접근하기 위해서 Getter/Setter 메서드를 추가해야 하므로 코드의 양이 늘어납니다.
코틀린에서는 property 를 제공합니다. fiedl 와 Getter/Setter 메서드를 함께 제공하며 자바와 유사하게 선언합니다.

코틀린에서 클래스의 멤버로 사용하는 프로퍼티는 초기값을 명시적으로 지정해야합니다.


### 접근 제한자
코틀린에서 접근 제한자를 사용하는 방법은 자바와 매우 유사하나 일부 차이가 있습니다.
제한자가 없으면 public 으로 간주하므로 이를 생략하는 것을 권장합니다.

`protected` 제한자를 사용해 접근 범위를 패키지 단위로 제한합니다.
하지만 이 제약은 그리 견고하지 않습니다. 코틀린에서는 이 단점을 보완하기 위해 `internal` 접근 제한자를 제공합니다. 
`internal` 접근 제한자는 동일한 모듈 내에 있는 클래스들로의 접근을 제한합니다.


### 생성자
코틀린은 `init` 블록을 사용해서 기본 생성자를 대체합니다.

생성자에 인자가 필요한 경우 primary constructor 를 사용합니다.

주 생성자 외에 다른 형태의 생성자가 필요한 경우 `constructor` 키워드를 사용해서 생성자를 선언할 수 있습니다.
추가 생성자를 정의하는 경우, 주 생성자를 반드시 호출해야 합니다.


### 함수
자바의 클래스 내 메서드를 함수로 표현합니다.


### 상속 및 인터페이스 구현
자바에서는 클래스 상속과 인터페이스 구현을 extends와 implements 로 구분하지만,
코틀린에서는 이를 구분하지 않고 : 뒤에 상속한 클래스나 구현한 인터페이스를 표기합니다.
클래스를 상속하는 경우 반드시 부모 클래스의 생성자를 호출해야 합니다.
부모 클래스의 생성자가 여러 형태일 경우, 별도의 생성자 선언에서 부모 클래스의 생성자를 호출하도록 합니다.

코틀린에서는 상속받거나 구현한 함수의 앞에 무조건 `override` 키워드를 붙이도록 강제합니다.

코틀린에서는 `open` 키워드를 붙인 클래스나 함수가 아니라면 클래스를 상속하거나 함수를 재정의할 수 없습니다.


### this
`this` 키워드는 클래스 자신을 지칭할 때 사용하며 코틀린에서도 동일한 용도로 사용합니다.

자바에서 {클래스이름}.this 형태의 표기를 코틀린에서는 this@{클래스 이름} 형태로 표기합니다.


### 정적 필드 및 메서드
일반적인 경우 클래스 내에 선언했던 정적 필드나 메서드는 패키지 단위로 선언할 수 있습니다.
```kotlin
package foo.bar

const val FOO = 123

fun foo() { }

class Foo {
    fun bar() { }
}
```
패키지 단위로 선언한 값이나 함수는 패키지에 종속되므로 다음과 같이 사용합니다.
```kotlin
import foo.bar.FOO
import foo.bar.foo

class Bar {
    fun bar() {
        val foo = FOO
        foo()
    }
}
```

패키지 단위 함수는 클래스 내 private 로 선언된 멤버에 접근해야 하는 factory method 는 구현할 수 없습니다.
이러한 경우 companion object 를 사용하면 클래스 내 모든 멤버에 접근할 수 있습니다.


### 싱글톤
코틀린에서는 싱글톤을 object 를 사용해서 구현 가능합니다.


### enum 클래스
자바의 enum 과 동일하며 선언 형태만 약간 다릅니다.


### 어노테이션 클래스
코틀린에서 어노테이션을 선언하는 방법은 다음과 같습니다.
`public @interface Foo` == `annotation class Foo`
```kotlin
annotation class Foo
```

코틀린에서 어노테이션 멤버로 사용할 수 있는 타입은 자바와 동일합니다.
- 자바 primitive type 에 대응하는 타입
- 문자열
- 클래스
- enum 클래스
- 멤버가 속한 어노테이션이 아닌 다른 어노테이션 클래스
- 위에 나열된 타입으로 구성된 배열

코틀린에서는 프로퍼티 자체에 어노테이션을 지정하는 것뿐 아니라, 프로퍼티를 구성하는 각 요소에 별도로 지정할 수 있도록
어노테이션에 적용 대상을 지정하는 기능을 제공합니다.


### 중첩 클래스
코틀린에서는 별도의 키워드를 붙이지 않으면 정적 중첩 클래스로 선언합니다.
비 정적 중첩 클래스로 선언하기 위해서는 `inner` 키워드를 추가합니다.


## 2.4 자료/자료형의 확인 및 변환

### 자료의 동일성 확인 ==, ===
자바에서는 `==` 연산자를 사용하면 객체의 값뿐 아니라 객체 자체가 동일한지 여부도 함께 확인합니다.
객체의 값만 비교하려면 equals() 메서드를 사용해야 합니다.
코틀린에서는 모두 `==` 연산자를 사용하면 됩니다.
코틀린의 `==` 연산자는 값의 널 여부를 함께 확인합니다.

객체 자체가 동일한지 여부에 대한 비교가 필요한 경우, 코틀린에서는 `===` 연산자를 사용하면 됩니다.


### 자료형 확인 : is 연산자
코틀린에서는 자료형을 확인하기 위해 `is` 연산자를 사용하며, 이는 자바의 `instanceOf` 연산자와 동일한 기능을 합니다.


### 자료형 변환 : as 연산자
자바에서는 변수를 자신이 원하는 자료형으로 변환하기 위해 괄호를 사용합니다.
코틀린에서는 괄호 대신 `as` 연산자를 사용하여 자료형을 변환합니다.


### 스마트 캐스트
자료형 추론이 가능할 경우 캐스팅 없이 해당하는 자료형으로 객체를 사용할 수 있는 스마트 캐스트 기능을 제공합니다.


## 2.5 흐름 제어

### if-else
자바와 마찬가지로 코틀린에서도 if-else 문을 사용하여 조건문을 작성할 수 있습니다.

자바와 달리 코틀린의 if-else 문은 값을 반환할 수 있습니다.
그래서 자바의 삼항 연산자를 대체할 수 있습니다.

### when
코틀린의 when 문은 자바의 switch 문을 대체합니다.

when 문도 if-else 문과 마찬가지로 값을 반환할 수 있습니다.

각 경우의 조건을 상수값만 지정할 수 있었던 자바와 달리, 코틀린에서는 각 조건을 expression 으로 작성할 수 있습니다.

### while 문
while 문 과 do while 문의 기능 및 문법은 자바와 완전히 동일합니다.

### for 문
자바가 인덱스 기반 for 문과 for-each 문을 지원하는 반면 코틀린은 for-each 형태만 지원하며,
반복자를 통해 접근하는 인자의 타입을 생략할 수 있습니다.

for 문에서 인덱스가 필요한 경우 `Collections.indicies` 프로퍼티를 사용하면 컬렉션의 인덱스를 순환하며
인덱스 인자로 배열 내 항목에 접근할 수 있습니다.

### range
코틀린에만 있는 독특한 자료구조로 특정 범위를 순환하거나 해당 범위 내에 특정 항목이 포함되어 있는지 확인할 때 사용합니다.
범위는 `..`연산자를 사용하여 정의합니다.

범위 내에 특정 항목이 있는지 알아보려면 in 연산자를 사용합니다.

항목들의 순서가 반대로 정렬된 범위를 생성하려면 `downTo()` 함수를 사용합니다. 
`step()` 을 사용하면 감소 폭을 변경할 수 있습니다.

